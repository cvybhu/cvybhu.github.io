<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Scylla Rust Driver</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for Scylla Rust Driver">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Scylla Rust Driver</a></li><li class="chapter-item expanded "><a href="quickstart/quickstart.html"><strong aria-hidden="true">1.</strong> Quick start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quickstart/create-project.html"><strong aria-hidden="true">1.1.</strong> Creating a project</a></li><li class="chapter-item expanded "><a href="quickstart/scylla-docker.html"><strong aria-hidden="true">1.2.</strong> Running Scylla using Docker</a></li><li class="chapter-item expanded "><a href="quickstart/example.html"><strong aria-hidden="true">1.3.</strong> Connecting and running a simple query</a></li></ol></li><li class="chapter-item expanded "><a href="connecting/connecting.html"><strong aria-hidden="true">2.</strong> Connecting to the cluster</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="connecting/compression.html"><strong aria-hidden="true">2.1.</strong> Compression</a></li><li class="chapter-item expanded "><a href="connecting/authentication.html"><strong aria-hidden="true">2.2.</strong> Authentication</a></li><li class="chapter-item expanded "><a href="connecting/tls.html"><strong aria-hidden="true">2.3.</strong> TLS</a></li></ol></li><li class="chapter-item expanded "><a href="queries/queries.html"><strong aria-hidden="true">3.</strong> Making queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="queries/simple.html"><strong aria-hidden="true">3.1.</strong> Simple query</a></li><li class="chapter-item expanded "><a href="queries/values.html"><strong aria-hidden="true">3.2.</strong> Query values</a></li><li class="chapter-item expanded "><a href="queries/result.html"><strong aria-hidden="true">3.3.</strong> Query result</a></li><li class="chapter-item expanded "><a href="queries/prepared.html"><strong aria-hidden="true">3.4.</strong> Prepared query</a></li><li class="chapter-item expanded "><a href="queries/batch.html"><strong aria-hidden="true">3.5.</strong> Batch statement</a></li><li class="chapter-item expanded "><a href="queries/paged.html"><strong aria-hidden="true">3.6.</strong> Paged query</a></li><li class="chapter-item expanded "><a href="queries/usekeyspace.html"><strong aria-hidden="true">3.7.</strong> USE keyspace</a></li></ol></li><li class="chapter-item expanded "><a href="data-types/data-types.html"><strong aria-hidden="true">4.</strong> Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-types/primitive.html"><strong aria-hidden="true">4.1.</strong> Bool, Tinyint, Smallint, Int, Bigint, Float, Double</a></li><li class="chapter-item expanded "><a href="data-types/text.html"><strong aria-hidden="true">4.2.</strong> Ascii, Text, Varchar</a></li><li class="chapter-item expanded "><a href="data-types/counter.html"><strong aria-hidden="true">4.3.</strong> Counter</a></li><li class="chapter-item expanded "><a href="data-types/blob.html"><strong aria-hidden="true">4.4.</strong> Blob</a></li><li class="chapter-item expanded "><a href="data-types/inet.html"><strong aria-hidden="true">4.5.</strong> Inet</a></li><li class="chapter-item expanded "><a href="data-types/uuid.html"><strong aria-hidden="true">4.6.</strong> Uuid, Timeuuid</a></li><li class="chapter-item expanded "><a href="data-types/date.html"><strong aria-hidden="true">4.7.</strong> Date</a></li><li class="chapter-item expanded "><a href="data-types/time.html"><strong aria-hidden="true">4.8.</strong> Time</a></li><li class="chapter-item expanded "><a href="data-types/timestamp.html"><strong aria-hidden="true">4.9.</strong> Timestamp</a></li><li class="chapter-item expanded "><a href="data-types/decimal.html"><strong aria-hidden="true">4.10.</strong> Decimal</a></li><li class="chapter-item expanded "><a href="data-types/varint.html"><strong aria-hidden="true">4.11.</strong> Varint</a></li><li class="chapter-item expanded "><a href="data-types/collections.html"><strong aria-hidden="true">4.12.</strong> List, Set, Map</a></li><li class="chapter-item expanded "><a href="data-types/tuple.html"><strong aria-hidden="true">4.13.</strong> Tuple</a></li><li class="chapter-item expanded "><a href="data-types/udt.html"><strong aria-hidden="true">4.14.</strong> UDT (User defined type)</a></li></ol></li><li class="chapter-item expanded "><a href="load-balancing/load-balancing.html"><strong aria-hidden="true">5.</strong> Load balancing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="load-balancing/robin.html"><strong aria-hidden="true">5.1.</strong> Round robin</a></li><li class="chapter-item expanded "><a href="load-balancing/dc-robin.html"><strong aria-hidden="true">5.2.</strong> DC Aware Round robin</a></li><li class="chapter-item expanded "><a href="load-balancing/token-robin.html"><strong aria-hidden="true">5.3.</strong> Token aware Round robin</a></li><li class="chapter-item expanded "><a href="load-balancing/token-dc-robin.html"><strong aria-hidden="true">5.4.</strong> Token aware DC Aware Round robin</a></li></ol></li><li class="chapter-item expanded "><a href="retry-policy/retry-policy.html"><strong aria-hidden="true">6.</strong> Retry policy configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="retry-policy/fallthrough.html"><strong aria-hidden="true">6.1.</strong> Fallthrough retry policy</a></li><li class="chapter-item expanded "><a href="retry-policy/default.html"><strong aria-hidden="true">6.2.</strong> Default retry policy</a></li></ol></li><li class="chapter-item expanded "><a href="metrics/metrics.html"><strong aria-hidden="true">7.</strong> Driver metrics</a></li><li class="chapter-item expanded "><a href="tracing/tracing.html"><strong aria-hidden="true">8.</strong> Query tracing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Scylla Rust Driver</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/scylladb/scylla-rust-driver" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scylla-rust-driver"><a class="header" href="#scylla-rust-driver">Scylla Rust Driver</a></h1>
<p>This book contains documentation for <a href="https://github.com/scylladb/scylla-rust-driver">scylla-rust-driver</a> - a driver
for the <a href="https://scylladb.com">Scylla</a> database written in Rust. 
Although optimized for Scylla, the driver is also compatible with <a href="https://cassandra.apache.org/">Apache Cassandra®</a>.</p>
<h3 id="other-documentation"><a class="header" href="#other-documentation">Other documentation</a></h3>
<ul>
<li><a href="https://github.com/scylladb/scylla-rust-driver/tree/main/examples">Examples</a></li>
<li><em>API documentation</em> (Coming soon, for now download the <a href="https://github.com/scylladb/scylla-rust-driver">repo</a> and run <code>cargo doc</code>)</li>
<li><a href="https://docs.scylladb.com">Scylla documentation</a></li>
<li><a href="https://cassandra.apache.org/doc/latest/">Cassandra® documentation</a></li>
</ul>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<ul>
<li><a href="quickstart/quickstart.html">Quick start</a> - Setting up a Rust project using <code>scylla-rust-driver</code> and running a few queries</li>
<li><a href="connecting/connecting.html">Connecting to the cluster</a> - Configuring a connection to scylla cluster</li>
<li><a href="queries/queries.html">Making queries</a> - Making different types of queries (simple, prepared, batch, paged)</li>
</ul>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>In this chapter we will set up a Rust project and run a few simple queries.</p>
<h1 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h1>
<p>To create a new project run:</p>
<pre><code class="language-shell">cargo new myproject
</code></pre>
<p>In <code>Cargo.toml</code> add required dependencies:</p>
<pre><code class="language-toml">[dependencies]
scylla = { git = &quot;https://github.com/scylladb/scylla-rust-driver&quot;, branch = &quot;main&quot; }
tokio = { version = &quot;1.1.0&quot;, features = [&quot;full&quot;] }
futures = &quot;0.3.6&quot;
</code></pre>
<blockquote>
<p>Note that when specifying a dependency as a git link, updates will not be automatically pulled.
Running <code>cargo update</code> will update the git dependency manually.</p>
</blockquote>
<p>In <code>main.rs</code> put:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">extern crate scylla;
</span><span class="boring">extern crate tokio;
</span>use scylla::Session;

#[tokio::main]
async fn main() {
    println!(&quot;Hello scylla!&quot;);
}
</code></pre></pre>
<p>Now running <code>cargo run</code> should print:</p>
<pre><code class="language-shell">Hello scylla!
</code></pre>
<h1 id="running-scylla-using-docker"><a class="header" href="#running-scylla-using-docker">Running Scylla using Docker</a></h1>
<p>To make queries we will need a running Scylla instance. The easiest way is to use a <a href="https://www.docker.com/">Docker</a> image.<br />
Please <a href="https://docs.docker.com/engine/install">install Docker</a> if it's not installed.</p>
<h3 id="linux"><a class="header" href="#linux">Linux:</a></h3>
<p>To start Scylla run:</p>
<pre><code class="language-shell">sudo docker run --rm -it -p 9042:9042 scylladb/scylla --smp 2
</code></pre>
<p>Docker will download the image, then after minute or two there should be a message like:</p>
<pre><code class="language-shell">Starting listening for CQL clients on 172.17.0.2:9042
</code></pre>
<p>This means that Scylla is ready to receive queries</p>
<p>To stop this instance press <code>Ctrl + C</code></p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>TODO</p>
<h3 id="more-information"><a class="header" href="#more-information">More information</a></h3>
<p>More information about this image can be found on <a href="https://hub.docker.com/r/scylladb/scylla">dockerhub</a></p>
<h1 id="connecting-and-running-a-simple-query"><a class="header" href="#connecting-and-running-a-simple-query">Connecting and running a simple query</a></h1>
<p>Now everything is ready to use the driver.
Here is a small example:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">extern crate scylla;
</span><span class="boring">extern crate tokio;
</span>use scylla::{IntoTypedRows, Session, SessionBuilder};
use std::error::Error;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Create a new Session which connects to node at 127.0.0.1:9042
    let session: Session = SessionBuilder::new()
        .known_node(&quot;127.0.0.1:9042&quot;)
        .build()
        .await?;

    // Create an example keyspace and table
    session
        .query(
            &quot;CREATE KEYSPACE IF NOT EXISTS ks WITH REPLICATION = \
            {'class' : 'SimpleStrategy', 'replication_factor' : 1}&quot;,
            &amp;[],
        )
        .await?;

    session
        .query(
            &quot;CREATE TABLE IF NOT EXISTS ks.extab (a int primary key)&quot;,
            &amp;[],
        )
        .await?;

    // Insert a value into the table
    let to_insert: i32 = 12345;
    session
        .query(&quot;INSERT INTO ks.extab (a) VALUES(?)&quot;, (to_insert,))
        .await?;

    // Query rows from the table and print them
    if let Some(rows) = session.query(&quot;SELECT a FROM ks.extab&quot;, &amp;[]).await? {
        // Parse each row as a tuple containing single i32
        for row in rows.into_typed::&lt;(i32,)&gt;() {
            let read_row: (i32,) = row?;
            println!(&quot;Read a value from row: {}&quot;, read_row.0);
        }
    }

    Ok(())
}
</code></pre></pre>
<h1 id="connecting-to-the-cluster"><a class="header" href="#connecting-to-the-cluster">Connecting to the cluster</a></h1>
<p>Scylla is a distributed database, which means that it operates on multiple nodes running independently.
When creating a <code>Session</code> you can specify a few known nodes to which the driver will try connecting:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">extern crate scylla;
</span><span class="boring">extern crate tokio;
</span>use scylla::{Session, SessionBuilder};
use std::error::Error;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let session: Session = SessionBuilder::new()
        .known_node(&quot;127.0.0.1:9042&quot;)
        .known_node(&quot;localhost:8000&quot;)
        .known_node_addr(SocketAddr::new(
            IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)),
            9000,
        ))
        .build()
        .await?;

    Ok(())
}
</code></pre></pre>
<p>After succesfully connecting to some specified node the driver will fetch topology information about
other nodes in this cluster and connect to them as well.</p>
<h1 id="compression"><a class="header" href="#compression">Compression</a></h1>
<p>By default the driver does not use any compression on connections.<br />
It's possible to specify a preferred compression algorithm.<br />
The driver will try using it, but if the database doesn't support it, it will fall back to no compression.</p>
<p>Available compression algorithms:</p>
<ul>
<li>Snappy</li>
<li>LZ4</li>
</ul>
<p>An example enabling <code>Snappy</code> compression algorithm:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">extern crate scylla;
</span><span class="boring">extern crate tokio;
</span>use scylla::{Session, SessionBuilder};
use scylla::transport::Compression;
use std::error::Error;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let session: Session = SessionBuilder::new()
        .known_node(&quot;127.0.0.1:9042&quot;)
        .compression(Some(Compression::Snappy))
        .build()
        .await?;

    Ok(())
}
</code></pre></pre>
<h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>Authentication is still in development, see pull request <a href="https://github.com/scylladb/scylla-rust-driver/pull/177">#177</a></p>
<h1 id="tls"><a class="header" href="#tls">TLS</a></h1>
<p>TLS support is still in development, see pull request <a href="https://github.com/scylladb/scylla-rust-driver/pull/191">#191</a></p>
<h1 id="making-queries"><a class="header" href="#making-queries">Making queries</a></h1>
<p>This driver supports all query types available in Scylla:</p>
<ul>
<li><a href="queries/simple.html">Simple queries</a>
<ul>
<li>Easy to use</li>
<li>Poor performance</li>
<li>Primitve load balancing</li>
</ul>
</li>
<li><a href="queries/prepared.html">Prepared queries</a>
<ul>
<li>Need to be prepared before use</li>
<li>Fast</li>
<li>Properly load balanced</li>
</ul>
</li>
<li><a href="queries/batch.html">Batch statements</a>
<ul>
<li>Run multiple queries at once</li>
<li>Can be prepared for better performance and load balancing</li>
</ul>
</li>
<li><a href="queries/paged.html">Paged queries</a>
<ul>
<li>Allows to read result in multiple pages when it doesn't fit in a single response</li>
<li>Can be prepared for better performance and load balancing</li>
</ul>
</li>
</ul>
<p>Additionaly there is special functionality to enable <code>USE KEYSPACE</code> queries:
<a href="queries/usekeyspace.html">USE keyspace</a></p>
<p>Queries are fully asynchronous - you can run as many of them in parallel as you wish.</p>
<h1 id="simple-query"><a class="header" href="#simple-query">Simple query</a></h1>
<p>Simple query takes query text and values and simply executes them on a <code>Session</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn simple_query_example(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>// Insert a value into the table
let to_insert: i32 = 12345;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><em><strong>Warning</strong></em><br />
Simple query returns only a single page of results.
If number of rows might exceed single page size use a <a href="queries/paged.html">paged query</a> instead.</p>
</blockquote>
<h3 id="first-argument---the-query"><a class="header" href="#first-argument---the-query">First argument - the query</a></h3>
<p>As the first argument <code>Session::query</code> takes anything implementing <code>Into&lt;Query&gt;</code>.<br />
You can create a query manually to set custom options. For example to change query consistency:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::query::Query;
use scylla::statement::Consistency;

// Create a Query manually to change the Consistency to ONE
let mut my_query: Query = Query::new(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;.to_string());
my_query.set_consistency(Consistency::One);

// Insert a value into the table
let to_insert: i32 = 12345;
session.query(my_query, (to_insert,)).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>See <a href="queries/">Query API documentation (TODO)</a> for more options</p>
<h3 id="second-argument---the-values"><a class="header" href="#second-argument---the-values">Second argument - the values</a></h3>
<p>Query text is constant, but the values might change.
You can pass changing values to a query by specifying a list of variables as bound values.<br />
Each <code>?</code> in query text will be filled with the matching value. </p>
<p>The easiest way is to pass values using a tuple:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>// Sending an integer and a string using a tuple
session
    .query(&quot;INSERT INTO ks.tab (a, b, c) VALUES(?, ?, 'text2')&quot;, (2_i32, &quot;Some text&quot;))
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Here the first <code>?</code> will be filled with <code>2</code> and the second with <code>&quot;Some text&quot;</code>.</p>
<blockquote>
<p><strong>Never</strong> pass values by adding strings, this could lead to <a href="https://en.wikipedia.org/wiki/SQL_injection">SQL Injection</a></p>
</blockquote>
<p>See <a href="queries/values.html">Query values</a> for more information about sending values in queries</p>
<h3 id="query-result"><a class="header" href="#query-result">Query result</a></h3>
<p><code>Session::query</code> returns <code>Option&lt;Vec&lt;Row&gt;&gt;</code><br />
Each row can be parsed as a tuple of rust types using <code>into_typed</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Query rows from the table and print them
if let Some(rows) = session.query(&quot;SELECT a FROM ks.tab&quot;, &amp;[]).await? {
    // Parse each row as a tuple containing single i32
    for row in rows.into_typed::&lt;(i32,)&gt;() {
        let read_row: (i32,) = row?;
        println!(&quot;Read a value from row: {}&quot;, read_row.0);
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Simple query returns only a single page of results.
If number of rows might exceed single page size use a <a href="queries/paged.html">paged query</a> instead.</p>
</blockquote>
<p>See <a href="queries/result.html">Query result</a> for more information about handling query results</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Simple queries should not be used in places where performance matters.<br />
If perfomance matters use a <a href="queries/prepared.html">Prepared query</a> instead.</p>
<p>With simple query the database has to parse query text each time it's executed, which worsens performance.</p>
<p>Additionaly token and shard aware load balancing does not work with simple queries. They are sent to random nodes.</p>
<h1 id="query-values"><a class="header" href="#query-values">Query values</a></h1>
<p>Query text is constant, but the values might change.
You can pass changing values to a query by specifying a list of variables as bound values.<br />
Each <code>?</code> in query text will be filled with the matching value. </p>
<blockquote>
<p><strong>Never</strong> pass values by adding strings, this could lead to <a href="https://en.wikipedia.org/wiki/SQL_injection">SQL Injection</a></p>
</blockquote>
<p>Each list of values to send in a query must implement the trait <code>ValueList</code>.<br />
By default this can be a slice <code>&amp;[]</code> or a tuple <code>()</code> (max 16 elements) of values to send.</p>
<p>A few examples:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>// Empty slice means that there are no values to send
session.query(&quot;INSERT INTO ks.tab (a) VALUES(1)&quot;, &amp;[]).await?;

// Empty tuple/unit also means that there are no values to send
session.query(&quot;INSERT INTO ks.tab (a) VALUES(1)&quot;, ()).await?;

// Sending three integers using a slice:
session
    .query(&quot;INSERT INTO ks.tab (a, b, c) VALUES(?, ?, ?)&quot;, [1_i32, 2, 3].as_ref())
    .await?;

// Sending an integer and a string using a tuple
session
    .query(&quot;INSERT INTO ks.tab (a, b) VALUES(?, ?)&quot;, (2_i32, &quot;Some text&quot;))
    .await?;

// Sending a single value as a tuple requires a trailing coma (Rust syntax):
session.query(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;, (2_i32,)).await?;

// Each value can also be sent using a reference:
session
    .query(&quot;INSERT INTO ks.tab (a, b) VALUES(?, ?)&quot;, &amp;(&amp;2_i32, &amp;&quot;Some text&quot;))
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="null-values"><a class="header" href="#null-values"><code>NULL</code> values</a></h3>
<p>Null values can be sent using <code>Option&lt;&gt;</code> - sending a <code>None</code> will make the value <code>NULL</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>let null_i32: Option&lt;i32&gt; = None;
session
    .query(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;, (null_i32,))
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="unset-values"><a class="header" href="#unset-values"><code>Unset</code> values</a></h3>
<p>When performing an insert with values which might be <code>NULL</code>, it's better to use <code>Unset</code>.<br />
Database treats inserting <code>NULL</code> as a delete operation and will generate a tombstone.
Using <code>Unset</code> results in better performance:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::frame::value::{MaybeUnset, Unset};

// Inserting a null results in suboptimal performance
let null_i32: Option&lt;i32&gt; = None;
session
    .query(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;, (null_i32,))
    .await?;

// Using MaybeUnset enum is better
let unset_i32: MaybeUnset&lt;i32&gt; = MaybeUnset::Unset;
session
    .query(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;, (unset_i32,))
    .await?;

// If we are sure that a value should be unset we can simply use Unset
session
    .query(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;, (Unset,))
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>See the <a href="https://issues.apache.org/jira/browse/CASSANDRA-7304">issue</a> for more information about <code>Unset</code></p>
<h3 id="other-data-types"><a class="header" href="#other-data-types">Other data types</a></h3>
<p>See <a href="queries/../data-types/data-types.html">Data Types</a> for instructions on sending other data types</p>
<h1 id="query-result-1"><a class="header" href="#query-result-1">Query result</a></h1>
<p><code>Session::query</code> and <code>Session::execute</code> return a list of rows received as <code>Option&lt;Vec&lt;Row&gt;&gt;</code>.</p>
<h3 id="basic-representation"><a class="header" href="#basic-representation">Basic representation</a></h3>
<p><code>Row</code> is a basic representation of a received row. It can be used by itself, but it's a bit awkward to use:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>if let Some(rows) = session.query(&quot;SELECT a from ks.tab&quot;, &amp;[]).await? {
    for row in rows {
        let int_value: i32 = row.columns[0].as_ref().unwrap().as_int().unwrap();
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="parsing-using-into_typed"><a class="header" href="#parsing-using-into_typed">Parsing using <code>into_typed</code></a></h3>
<p>The driver provides a way to parse a row as a tuple of Rust types:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Parse row as a single column containing an int value
if let Some(rows) = session.query(&quot;SELECT a from ks.tab&quot;, &amp;[]).await? {
    for row in rows {
        let (int_value,): (i32,) = row.into_typed::&lt;(i32,)&gt;()?;
    }
}

// rows.into_typed() converts a Vec of Rows to an iterator of parsing results
if let Some(rows) = session.query(&quot;SELECT a from ks.tab&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(i32,)&gt;() {
        let (int_value,): (i32,) = row?;
    }
}

// Parse row as two columns containing an int and text columns
if let Some(rows) = session.query(&quot;SELECT a from ks.tab&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(i32, String)&gt;() {
        let (int_value, text_value): (i32, String) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="null-values-1"><a class="header" href="#null-values-1"><code>NULL</code> values</a></h3>
<p><code>NULL</code> values will return an error when parsed as a Rust type. 
To properly handle <code>NULL</code> values parse column as an <code>Option&lt;&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Parse row as two columns containing an int and text which might be null
if let Some(rows) = session.query(&quot;SELECT a from ks.tab&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(i32, Option&lt;String&gt;)&gt;() {
        let (int_value, str_or_null): (i32, Option&lt;String&gt;) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="other-data-types-1"><a class="header" href="#other-data-types-1">Other data types</a></h3>
<p>For parsing other data types see <a href="queries/../data-types/data-types.html">Data Types</a></p>
<h1 id="prepared-query"><a class="header" href="#prepared-query">Prepared query</a></h1>
<p>Prepared queries provide much better performance than simple queries, 
but they need to be prepared before use.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::prepared_statement::PreparedStatement;

// Prepare the query for later execution
let prepared: PreparedStatement = session
    .prepare(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;)
    .await?;

// Run the prepared query with some values, just like a simple query
let to_insert: i32 = 12345;
session.execute(&amp;prepared, (to_insert,)).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><em><strong>Warning</strong></em><br />
For token/shard aware load balancing to work properly, all partition key values
must be sent as bound values (see <a href="queries/prepared.html#performance">performance section</a>)</p>
</blockquote>
<blockquote>
<p><em><strong>Warning</strong></em><br />
Prepared query returns only a single page of results.
If number of rows might exceed single page size use a <a href="queries/paged.html">paged query</a> instead.</p>
</blockquote>
<h3 id="sessionprepare"><a class="header" href="#sessionprepare"><code>Session::prepare</code></a></h3>
<p><code>Session::prepare</code> takes query text and prepares the query on all nodes and shards.
If at least one succeds returns success.</p>
<h3 id="sessionexecute"><a class="header" href="#sessionexecute"><code>Session::execute</code></a></h3>
<p><code>Session::execute</code> takes a prepared query and bound values and runs the query.
Passing values and the result is the same as in <a href="queries/simple.html">simple query</a>.</p>
<h3 id="query-options"><a class="header" href="#query-options">Query options</a></h3>
<p>To specify custom options, set them on the <code>PreparedStatement</code> before execution.<br />
For example to change the consistency:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::prepared_statement::PreparedStatement;
use scylla::statement::Consistency;

// Prepare the query for later execution
let mut prepared: PreparedStatement = session
    .prepare(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;)
    .await?;

// Set prepared query consistency to One
// This is the consistency with which this query will be executed
prepared.set_consistency(Consistency::One);

// Run the prepared query with some values, just like a simple query
let to_insert: i32 = 12345;
session.execute(&amp;prepared, (to_insert,)).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<p>Prepared queries have good performance, much better than simple queries.<br />
By default they use shard/token aware load balancing.</p>
<blockquote>
<p><strong>Always</strong> pass partition key values as bound values. 
Otherwise the driver can't hash them to compute partition key 
and they will be sent to the wrong node, which worsens performance.</p>
</blockquote>
<p>Let's say we have a table like this:</p>
<pre><code class="language-sql">TABLE ks.prepare_table (
    a int,
    b int,
    c int,
    PRIMARY KEY (a, b)
)
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::prepared_statement::PreparedStatement;

// WRONG - partition key value is passed in query string
// Load balancing will compute the wrong partition key
let wrong_prepared: PreparedStatement = session
    .prepare(&quot;INSERT INTO ks.prepare_table (a, b, c) VALUES(12345, ?, 16)&quot;)
    .await?;

session.execute(&amp;wrong_prepared, (54321,)).await?;

// GOOD - partition key values are sent as bound values
// Other values can be sent any way you like, it doesn't matter
let good_prepared: PreparedStatement = session
    .prepare(&quot;INSERT INTO ks.prepare_table (a, b, c) VALUES(?, ?, 16)&quot;)
    .await?;

session.execute(&amp;good_prepared, (12345, 54321)).await?;

<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="batch-statement"><a class="header" href="#batch-statement">Batch statement</a></h1>
<p>A batch statement allows to run many queries at once.<br />
These queries can be <a href="queries/simple.html">simple queries</a> or <a href="queries/prepared.html">prepared queries</a>.<br />
Only queries like <code>INSERT</code> or <code>UPDATE</code> can be in a batch, batch doesn't return any rows.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::batch::Batch;
use scylla::query::Query;
use scylla::prepared_statement::PreparedStatement;

// Create a batch statement
let mut batch: Batch = Default::default();

// Add a simple query to the batch using its text
batch.append_statement(&quot;INSERT INTO ks.tab(a, b) VALUES(?, ?)&quot;);

// Add a simple query created manually to the batch
let simple: Query = Query::new(&quot;INSERT INTO ks.tab (a, b) VALUES(3, 4)&quot;.to_string());
batch.append_statement(simple);

// Add a prepared query to the batch
let prepared: PreparedStatement = session
    .prepare(&quot;INSERT INTO ks.tab (a, b) VALUES(?, 6)&quot;)
    .await?;
batch.append_statement(prepared);

// Specify bound values to use with each query
let batch_values = ((1_i32, 2_i32),
                    (),
                    (5_i32,));

// Run the batch, doesn't return any rows
session.batch(&amp;batch, batch_values).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="batch-options"><a class="header" href="#batch-options">Batch options</a></h3>
<p>You can set various options by operating on the <code>Batch</code> object.<br />
For example to change consistency:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::batch::Batch;
use scylla::statement::Consistency;

// Create a batch
let mut batch: Batch = Default::default();
batch.append_statement(&quot;INSERT INTO ks.tab(a) VALUES(16)&quot;);

// Set batch consistency to One
batch.set_consistency(Consistency::One);

// Run the batch
session.batch(&amp;batch, ((), )).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="batch-values"><a class="header" href="#batch-values">Batch values</a></h3>
<p>Batch takes a tuple of values specified just like in <a href="queries/simple.html">simple</a> or <a href="queries/prepared.html">prepared</a> queries.</p>
<p>Length of batch values must be equal to the number of statements in a batch.<br />
Each query must have its values specified, even if they are empty.</p>
<p>Values passed to <code>Session::batch</code> must implement the trait <code>BatchValues</code>.<br />
By default this includes tuples <code>()</code> and slices <code>&amp;[]</code> of tuples and slices which implement <code>ValueList</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::batch::Batch;

let mut batch: Batch = Default::default();

// A query with two bound values
batch.append_statement(&quot;INSERT INTO ks.tab(a, b) VALUES(?, ?)&quot;);

// A query with one bound value
batch.append_statement(&quot;INSERT INTO ks.tab(a, b) VALUES(3, ?)&quot;);

// A query with no bound values
batch.append_statement(&quot;INSERT INTO ks.tab(a, b) VALUES(5, 6)&quot;);

// Batch values is a tuple of 3 tuples containing values for each query
let batch_values = ((1_i32, 2_i32), // Tuple with two values for the first query
                    (4_i32,),       // Tuple with one value for the second query
                    ());            // Empty tuple/unit for the third query

// Run the batch
session.batch(&amp;batch, batch_values).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>For more information about sending values in a query see <a href="queries/values.html">Query values</a></p>
<h3 id="performance-2"><a class="header" href="#performance-2">Performance</a></h3>
<p>Batch statements do not use token/shard aware load balancing, batches are sent to a random node.</p>
<p>Use <a href="queries/prepared.html">prepared queries</a> for best performance</p>
<h1 id="paged-query"><a class="header" href="#paged-query">Paged query</a></h1>
<p>Sometimes query results might not fit in a single page. Paged queries
allow to receive the whole result page by page.</p>
<p><code>Session::query_iter</code> and <code>Session::execute_iter</code> take a <a href="queries/simple.html">simple query</a> or a <a href="queries/prepared.html">prepared query</a>
and return an <code>async</code> iterator over result <code>Rows</code>.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Use <code>query_iter</code> to perform a <a href="queries/simple.html">simple query</a> with paging:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate futures;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use futures::stream::StreamExt;

let mut rows_stream = session
    .query_iter(&quot;SELECT a, b FROM ks.t&quot;, &amp;[])
    .await?
    .into_typed::&lt;(i32, i32)&gt;();

while let Some(next_row_res) = rows_stream.next().await {
    let (a, b): (i32, i32) = next_row_res?;
    println!(&quot;a, b: {}, {}&quot;, a, b);
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Use <code>execute_iter</code> to perform a <a href="queries/prepared.html">prepared query</a> with paging:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate futures;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use scylla::prepared_statement::PreparedStatement;
use futures::stream::StreamExt;

let prepared: PreparedStatement = session
    .prepare(&quot;SELECT a, b FROM ks.t&quot;)
    .await?;

let mut rows_stream = session
    .execute_iter(prepared, &amp;[])
    .await?
    .into_typed::&lt;(i32, i32)&gt;();

while let Some(next_row_res) = rows_stream.next().await {
    let (a, b): (i32, i32) = next_row_res?;
    println!(&quot;a, b: {}, {}&quot;, a, b);
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Query values can be passed to <code>query_iter</code> and <code>execute_iter</code> just like in a <a href="queries/simple.html">simple query</a></p>
<h3 id="configuring-page-size"><a class="header" href="#configuring-page-size">Configuring page size</a></h3>
<p>It's possible to configure the size of a single page.</p>
<p>On a <code>Query</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::query::Query;

let mut query: Query = Query::new(&quot;SELECT a, b FROM ks.t&quot;.to_string());
query.set_page_size(16);

let _ = session.query_iter(query, &amp;[]).await?; // ...
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>On a <code>PreparedStatement</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::prepared_statement::PreparedStatement;

let mut prepared: PreparedStatement = session
    .prepare(&quot;SELECT a, b FROM ks.t&quot;)
    .await?;

prepared.set_page_size(16);

let _ = session.execute_iter(prepared, &amp;[]).await?; // ...
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="performance-3"><a class="header" href="#performance-3">Performance</a></h3>
<p>Performance is the same as in non-paged variants.<br />
For the best performance use <a href="queries/prepared.html">prepared queries</a>.</p>
<h1 id="use-keyspace"><a class="header" href="#use-keyspace">USE keyspace</a></h1>
<p>Using a keyspace allows to omit keyspace name in queries.</p>
<p>For example in <code>cqlsh</code> one could write:</p>
<pre><code class="language-sql">cqlsh&gt; SELECT * FROM my_keyspace.table;

 a     | b     |
-------+-------+
 12345 | 54321 |

(1 rows)
cqlsh&gt; USE my_keyspace;
cqlsh:my_keyspace&gt; SELECT * FROM table;

 a     | b     |
-------+-------+
 12345 | 54321 |

(1 rows)

</code></pre>
<p>Tables from other keyspaces can still easily be accessed by using their keyspace names.</p>
<pre><code class="language-sql">cqlsh:my_keyspace&gt; SELECT * FROM other_keyspace.other_table;
</code></pre>
<p>In the driver this can be achieved using <code>Session::use_keyspace</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>session
    .query(&quot;INSERT INTO my_keyspace.tab (a) VALUES ('test1')&quot;, &amp;[])
    .await?;

session.use_keyspace(&quot;my_keyspace&quot;, false).await?;

// Now we can omit keyspace name in the query
session
    .query(&quot;INSERT INTO tab (a) VALUES ('test2')&quot;, &amp;[])
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>The first argument is the keyspace name.<br />
The second argument states whether this name is case sensitive.</p>
<h3 id="multiple-use-queries-at-once"><a class="header" href="#multiple-use-queries-at-once">Multiple use queries at once</a></h3>
<p>Don't run multiple <code>use_keyspace</code> queries at once. 
This could end up with half of connections using one keyspace and the other half using the other.</p>
<h3 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case sensitivity</a></h3>
<p>In CQL a keyspace name can be case insensitive (without <code>&quot;</code>) or case sensitive (with <code>&quot;</code>).<br />
If the second argument to <code>use_keyspace</code> is set to <code>true</code> this keyspace name will be wrapped in <code>&quot;</code>.<br />
It is best to avoid the problem altogether and just not create two keyspaces with the same name but different cases.</p>
<p>Let's see what happens when there are two keyspaces with the same name but different cases: <code>my_keyspace</code> and <code>MY_KEYSPACE</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>// lowercase name without case sensitivity will use my_keyspace
session.use_keyspace(&quot;my_keyspace&quot;, false).await?;

// lowercase name with case sensitivity will use my_keyspace
session.use_keyspace(&quot;my_keyspace&quot;, true).await?;

// uppercase name without case sensitivity will use my_keyspace
session.use_keyspace(&quot;MY_KEYSPACE&quot;, false).await?;

// uppercase name with case sensitivity will use MY_KEYSPACE
session.use_keyspace(&quot;MY_KEYSPACE&quot;, true).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>The driver maps database data types to matching Rust types
to achieve seamless sending and receiving of CQL values.</p>
<p>See the following chapters for examples on how to send and receive each data type.</p>
<p>See <a href="data-types/../queries/values.rs">Query values</a> for more information about sending values in queries.<br />
See <a href="data-types/../queries/result.rs">Query result</a> for more information about reading values from queries</p>
<p>Database types and their Rust equivalents:</p>
<ul>
<li><code>Boolean</code> &lt;----&gt; <code>bool</code></li>
<li><code>Tinyint</code>  &lt;----&gt;  <code>i8</code></li>
<li><code>Smallint</code> &lt;----&gt; <code>i16</code></li>
<li><code>Int</code> &lt;----&gt; <code>i32</code></li>
<li><code>BigInt</code> &lt;----&gt; <code>i64</code></li>
<li><code>Float</code> &lt;----&gt; <code>f32</code></li>
<li><code>Double</code> &lt;----&gt; <code>f64</code></li>
<li><code>Ascii</code>, <code>Text</code>, <code>Varchar</code> &lt;----&gt; <code>&amp;str</code>, <code>String</code></li>
<li><code>Counter</code> &lt;----&gt; <code>value::Counter</code></li>
<li><code>Blob</code> &lt;----&gt; <code>Vec&lt;u8&gt;</code></li>
<li><code>Inet</code> &lt;----&gt; <code>std::net::IpAddr</code></li>
<li><code>Uuid</code>, <code>Timeuuid</code> &lt;----&gt; <code>uuid::Uuid</code></li>
<li><code>Date</code> &lt;----&gt; <code>chrono::NaiveDate</code>, <code>u32</code></li>
<li><code>Time</code> &lt;----&gt; <code>chrono::Duration</code></li>
<li><code>Timestamp</code> &lt;----&gt; <code>chrono::Duration</code></li>
<li><code>Decimal</code> &lt;----&gt; <code>bigdecimal::Decimal</code></li>
<li><code>Varint</code> &lt;----&gt; <code>num_bigint::BigInt</code></li>
<li><code>List</code> &lt;----&gt; <code>Vec&lt;T&gt;</code></li>
<li><code>Set</code> &lt;----&gt; <code>Vec&lt;T&gt;</code></li>
<li><code>Map</code> &lt;----&gt; <code>std::collections::HashMap&lt;K, V&gt;</code></li>
<li><code>Tuple</code> &lt;----&gt; Rust tuples</li>
<li><code>UDT (User defined type)</code> &lt;----&gt; Custom user structs with macros</li>
</ul>
<h1 id="bool-tinyint-smallint-int-bigint-float-double"><a class="header" href="#bool-tinyint-smallint-int-bigint-float-double">Bool, Tinyint, Smallint, Int, Bigint, Float, Double</a></h1>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<p><code>Bool</code> is represented as rust <code>bool</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a bool into the table
let to_insert: bool = true;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a bool from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(bool,)&gt;() {
        let (bool_value,): (bool,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="tinyint"><a class="header" href="#tinyint">Tinyint</a></h3>
<p><code>Tinyint</code> is represented as rust <code>i8</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a tinyint into the table
let to_insert: i8 = 123;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a tinyint from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(i8,)&gt;() {
        let (tinyint_value,): (i8,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="smallint"><a class="header" href="#smallint">Smallint</a></h3>
<p><code>Smallint</code> is represented as rust <code>i16</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a smallint into the table
let to_insert: i16 = 12345;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a smallint from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(i16,)&gt;() {
        let (smallint_value,): (i16,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="int"><a class="header" href="#int">Int</a></h3>
<p><code>Int</code> is represented as rust <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert an int into the table
let to_insert: i32 = 12345;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read an int from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(i32,)&gt;() {
        let (int_value,): (i32,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="bigint"><a class="header" href="#bigint">Bigint</a></h3>
<p><code>Bigint</code> is represented as rust <code>i64</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a bigint into the table
let to_insert: i64 = 12345;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a bigint from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(i64,)&gt;() {
        let (bigint_value,): (i64,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="float"><a class="header" href="#float">Float</a></h3>
<p><code>Float</code> is represented as rust <code>f32</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a float into the table
let to_insert: f32 = 123.0;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a float from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(f32,)&gt;() {
        let (float_value,): (f32,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="double"><a class="header" href="#double">Double</a></h3>
<p><code>Double</code> is represented as rust <code>f64</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a double into the table
let to_insert: f64 = 12345.0;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a double from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(f64,)&gt;() {
        let (double_value,): (f64,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="ascii-text-varchar"><a class="header" href="#ascii-text-varchar">Ascii, Text, Varchar</a></h1>
<p><code>Ascii</code>, <code>Text</code> and <code>Varchar</code> are represented as <code>&amp;str</code> and <code>String</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert some text into the table as a &amp;str
let to_insert_str: &amp;str = &quot;abcdef&quot;;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert_str,))
    .await?;

// Insert some text into the table as a String
let to_insert_string: String = &quot;abcdef&quot;.to_string();
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert_string,))
    .await?;

// Read ascii/text/varchar from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(String,)&gt;() {
        let (text_value,): (String,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="counter"><a class="header" href="#counter">Counter</a></h1>
<p><code>Counter</code> is represented as <code>struct Counter(pub i64)</code><br />
<code>Counter</code> can't be inserted, it can only be read or updated.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use scylla::frame::value::Counter;

// Read counter from the table
if let Some(rows) = session.query(&quot;SELECT c FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(Counter,)&gt;() {
        let (counter_value,): (Counter,) = row?;
        let counter_int_value: i64 = counter_value.0;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="blob"><a class="header" href="#blob">Blob</a></h1>
<p><code>Blob</code> is represented as <code>Vec&lt;u8&gt;</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert some blob into the table as a Vec&lt;u8&gt;
// We can insert it by reference to not move the whole blob
let to_insert: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (&amp;to_insert,))
    .await?;

// Read blobs from the table
// TODO - Forgot to add into_typed for Blobs
/*
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(Vec&lt;u8&gt;,)&gt;() {
        let (blob_value,): (Vec&lt;u8&gt;,) = row?;
    }
}
*/
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="inet"><a class="header" href="#inet">Inet</a></h1>
<p><code>Inet</code> is represented as <code>std::net::IpAddr</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use std::net::{IpAddr, Ipv4Addr};

// Insert some ip address into the table
/*
TODO - Forgot to implement Value for IpAddr
let to_insert: IpAddr = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;
*/

// Read inet from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(IpAddr,)&gt;() {
        let (inet_value,): (IpAddr,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="uuid-timeuuid"><a class="header" href="#uuid-timeuuid">Uuid, Timeuuid</a></h1>
<p><code>Uuid</code> and <code>Timeuuid</code> are represented as <code>uuid::Uuid</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate uuid;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use uuid::Uuid;

// Insert some uuid/timeuuid into the table
let to_insert: Uuid = Uuid::parse_str(&quot;8e14e760-7fa8-11eb-bc66-000000000001&quot;)?;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read uuid/timeuuid from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(Uuid,)&gt;() {
        let (uuid_value,): (Uuid,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="date"><a class="header" href="#date">Date</a></h1>
<p>For most use cases <code>Date</code> can be represented as 
<a href="https://docs.rs/chrono/0.4.19/chrono/naive/struct.NaiveDate.html"><code>chrono::NaiveDate</code></a>.<br />
<code>NaiveDate</code> supports dates from -262145-1-1 to 262143-12-31.</p>
<p>For dates outside of this range you can use the raw <code>u32</code> representation.</p>
<h3 id="using-chrononaivedate"><a class="header" href="#using-chrononaivedate">Using <code>chrono::NaiveDate</code>:</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate chrono;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use chrono::naive::NaiveDate;

// Insert some date into the table
let to_insert: NaiveDate = NaiveDate::from_ymd(2021, 3, 24);
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read NaiveDate from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(NaiveDate,)&gt;() {
        let (date_value,): (NaiveDate,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="using-raw-u32-representation"><a class="header" href="#using-raw-u32-representation">Using raw <code>u32</code> representation</a></h3>
<p>Internally <code>Date</code> is represented as number of days since -5877641-06-23 i.e. 2^31 days before unix epoch.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::frame::value::Date;
use scylla::frame::response::result::CQLValue;

// Insert date using raw u32 representation
let to_insert: Date = Date(2_u32.pow(31)); // 1970-01-01 
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read raw Date from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows {
        let date_value: u32 = match row.columns[0] {
            Some(CQLValue::Date(date_value)) =&gt; date_value,
            _ =&gt; panic!(&quot;Should be a date!&quot;)
        };
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="time"><a class="header" href="#time">Time</a></h1>
<p><code>Time</code> is represented as <a href="https://docs.rs/chrono/0.4.19/chrono/struct.Duration.html"><code>chrono::Duration</code></a></p>
<p>Internally <code>Time</code> is represented as number of nanoseconds since midnight. 
It can't be negative or exceed <code>86399999999999</code> (24 hours).</p>
<p>When sending in a query it needs to be wrapped in <code>value::Time</code> to differentiate from <a href="data-types/timestamp.html"><code>Timestamp</code></a></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate chrono;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use scylla::frame::value::Time;
use chrono::Duration;

// Insert some time into the table
let to_insert: Duration = Duration::seconds(64);
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (Time(to_insert),))
    .await?;

// Read time from the table, no need for a wrapper here
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(Duration,)&gt;() {
        let (time_value,): (Duration,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h1>
<p><code>Timestamp</code> is represented as <a href="https://docs.rs/chrono/0.4.19/chrono/struct.Duration.html"><code>chrono::Duration</code></a></p>
<p>Internally <code>Timestamp</code> is represented as <code>i64</code> describing number of milliseconds since unix epoch.
Driver converts this to <code>chrono::Duration</code></p>
<p>When sending in a query it needs to be wrapped in <code>value::Timestamp</code> to differentiate from <a href="data-types/time.html"><code>Time</code></a></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate chrono;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use scylla::frame::value::Timestamp;
use chrono::Duration;

// Insert some timestamp into the table
let to_insert: Duration = Duration::seconds(64);
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (Timestamp(to_insert),))
    .await?;

// Read timestamp from the table, no need for a wrapper here
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(Duration,)&gt;() {
        let (timestamp_value,): (Duration,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="decimal"><a class="header" href="#decimal">Decimal</a></h1>
<p><code>Decimal</code> is represented as <a href="https://docs.rs/bigdecimal/0.2.0/bigdecimal/struct.BigDecimal.html"><code>bigdecimal::BigDecimal</code></a></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate bigdecimal;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use bigdecimal::BigDecimal;
use std::str::FromStr;

// Insert a decimal into the table
let to_insert: BigDecimal = BigDecimal::from_str(&quot;12345.0&quot;)?;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a decimal from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(BigDecimal,)&gt;() {
        let (decimal_value,): (BigDecimal,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="varint"><a class="header" href="#varint">Varint</a></h1>
<p><code>Varint</code> is represented as <a href="https://docs.rs/num-bigint/0.4.0/num_bigint/struct.BigInt.html"><code>num_bigint::BigInt</code></a></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">extern crate num_bigint;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use num_bigint::BigInt;
use std::str::FromStr;

// Insert a varint into the table
let to_insert: BigInt = BigInt::from_str(&quot;12345&quot;)?;
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a varint from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(BigInt,)&gt;() {
        let (varint_value,): (BigInt,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="list-set-map"><a class="header" href="#list-set-map">List, Set, Map</a></h1>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p><code>List</code> is represented as <code>Vec&lt;T&gt;</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a list of ints into the table
let to_insert: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (&amp;to_insert,))
    .await?;

// Read a list of ints from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(Vec&lt;i32&gt;,)&gt;() {
        let (list_value,): (Vec&lt;i32&gt;,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<p><code>Set</code> is represented as <code>Vec&lt;T&gt;</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a set of ints into the table
let to_insert: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (&amp;to_insert,))
    .await?;

// Read a set of ints from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(Vec&lt;i32&gt;,)&gt;() {
        let (set_value,): (Vec&lt;i32&gt;,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p><code>Map</code> is represented as <code>std::collections::HashMap&lt;K, V&gt;</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use std::collections::HashMap;

// Insert a map of text and int into the table
let mut to_insert: HashMap&lt;String, i32&gt; = HashMap::new();
to_insert.insert(&quot;abcd&quot;.to_string(), 16);

session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (&amp;to_insert,))
    .await?;

// Read a map from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(HashMap&lt;String, i32&gt;,)&gt;() {
        let (map_value,): (HashMap&lt;String, i32&gt;,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<p><code>Tuple</code> is represented as rust tuples of max 16 elements.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;

// Insert a tuple of int and string into the table
let to_insert: (i32, String) = (1, &quot;abc&quot;.to_string());
session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read a tuple of int and string from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;((i32, String),)&gt;() {
        let (tuple_value,): ((i32, String),) = row?;
        
        let int_value: i32 = tuple_value.0;
        let string_value: String = tuple_value.1;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="user-defined-types"><a class="header" href="#user-defined-types">User defined types</a></h1>
<p>Scylla allows users to define their own data types with named fields.<br />
The driver supports this by allowing to create a custom struct with derived functionality.</p>
<p>For example let's say <code>my_type</code> was created using this query:</p>
<pre><code class="language-sql">CREATE TYPE ks.my_type (int_val int, text_val text)
</code></pre>
<p>To use this type in the driver create a matching struct and derive <code>IntoUserType</code> and <code>FromUserType</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::IntoTypedRows;
use scylla::macros::{FromUserType, IntoUserType};
use scylla::cql_to_rust::FromCQLVal;

// Define custom struct that matches User Defined Type created earlier
// wrapping field in Option will gracefully handle null field values
#[derive(Debug, IntoUserType, FromUserType)]
struct MyType {
    int_val: i32,
    text_val: Option&lt;String&gt;,
}

// Now it can be sent and received like any other value

// Insert my_type into the table
let to_insert = MyType {
    int_val: 17,
    text_val: Some(&quot;Some string&quot;.to_string()),
};

session
    .query(&quot;INSERT INTO keyspace.table (a) VALUES(?)&quot;, (to_insert,))
    .await?;

// Read MyType from the table
if let Some(rows) = session.query(&quot;SELECT a FROM keyspace.table&quot;, &amp;[]).await? {
    for row in rows.into_typed::&lt;(MyType,)&gt;() {
        let (my_type_value,): (MyType,) = row?;
    }
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="load-balancing"><a class="header" href="#load-balancing">Load balancing</a></h1>
<p>There are multiple load balancing strategies that the driver can use.<br />
Load balancing can be configured for the whole <code>Session</code> during creation.</p>
<p>Basic load balancing strategies:</p>
<ul>
<li><code>RoundRobinPolicy</code> - uses all known nodes one after another</li>
<li><code>DCAwareRoundRobinPolicy</code> - uses all known nodes from the local datacenter one after another</li>
</ul>
<p>Each of these basic load balancing strategies can be wrapped in <code>TokenAwarePolicy</code> to enable token awareness.</p>
<blockquote>
<p><strong>Note</strong><br />
Only <a href="load-balancing/../queries/prepared.html">prepared queries</a> use token aware load balancing</p>
</blockquote>
<p>So, the available load balancing policies are:</p>
<ul>
<li><a href="load-balancing/robin.html">Round robin</a></li>
<li><a href="load-balancing/dc-robin.html">DC Aware Round robin</a></li>
<li><a href="load-balancing/token-robin.html">Token aware Round robin</a></li>
<li><a href="load-balancing/token-dc-robin.html">Token aware DC Aware Round robin</a></li>
</ul>
<p>By default the driver uses <code>Token aware Round robin</code></p>
<h1 id="round-robin"><a class="header" href="#round-robin">Round robin</a></h1>
<p>The simplest load balancing policy available.<br />
Takes all nodes in the cluster and uses them one after another.</p>
<p>For example if there are nodes <code>A</code>, <code>B</code>, <code>C</code> in the cluster, 
this policy will use <code>A</code>, <code>B</code>, <code>C</code>, <code>A</code>, <code>B</code>, ...</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>To use this policy in <code>Session</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::{Session, SessionBuilder};
use scylla::transport::load_balancing::RoundRobinPolicy;
use std::sync::Arc;

let session: Session = SessionBuilder::new()
    .known_node(&quot;127.0.0.1:9042&quot;)
    .load_balancing(Arc::new(RoundRobinPolicy::new()))
    .build()
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="dc-aware-round-robin"><a class="header" href="#dc-aware-round-robin">DC Aware Round robin</a></h1>
<p>This is a more sophisticated version of <a href="load-balancing/robin.html">Round robin policy</a>.
It takes all nodes in the local datacenter and uses them one after another.<br />
If no nodes from the local datacenter are available it will fall back to other nodes.</p>
<p>For example if there are two datacenters:</p>
<ul>
<li><code>us_east</code> with nodes: <code>A</code>, <code>B</code>, <code>C</code></li>
<li><code>us_west</code> with nodes: <code>D</code>, <code>E</code>, <code>F</code></li>
</ul>
<p>this policy when set to <code>us_east</code> will only use <code>A</code>, <code>B</code>, <code>C</code>, <code>A</code>, <code>B</code>, ...</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>To use this policy in <code>Session</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::{Session, SessionBuilder};
use scylla::transport::load_balancing::DCAwareRoundRobinPolicy;
use std::sync::Arc;

let local_dc_name: String = &quot;us_east&quot;.to_string();

let session: Session = SessionBuilder::new()
    .known_node(&quot;127.0.0.1:9042&quot;)
    .load_balancing(Arc::new(DCAwareRoundRobinPolicy::new(local_dc_name)))
    .build()
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="token-aware-round-robin"><a class="header" href="#token-aware-round-robin">Token aware Round robin</a></h1>
<p>This policy will try to calculate a token to find replica nodes in which queried data is stored.<br />
After finding the replicas it performs a round robin on them.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>To use this policy in <code>Session</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::{Session, SessionBuilder};
use scylla::transport::load_balancing::{RoundRobinPolicy, TokenAwarePolicy};
use std::sync::Arc;

let robin = Box::new(RoundRobinPolicy::new());
let policy = Arc::new(TokenAwarePolicy::new(robin));

let session: Session = SessionBuilder::new()
    .known_node(&quot;127.0.0.1:9042&quot;)
    .load_balancing(policy)
    .build()
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="token-aware-dc-aware-round-robin"><a class="header" href="#token-aware-dc-aware-round-robin">Token aware DC Aware Round robin</a></h1>
<p>This policy will try to calculate a token to find replica nodes in which queried data is stored.<br />
After finding the replicas it chooses the ones from the local datacenter and performs a round robin on them.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>To use this policy in <code>Session</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::{Session, SessionBuilder};
use scylla::transport::load_balancing::{DCAwareRoundRobinPolicy, TokenAwarePolicy};
use std::sync::Arc;

let local_dc: String = &quot;us_east&quot;.to_string();
let dc_robin = Box::new(DCAwareRoundRobinPolicy::new(local_dc));
let policy = Arc::new(TokenAwarePolicy::new(dc_robin));

let session: Session = SessionBuilder::new()
    .known_node(&quot;127.0.0.1:9042&quot;)
    .load_balancing(policy)
    .build()
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="retry-policy-configuration"><a class="header" href="#retry-policy-configuration">Retry policy configuration</a></h1>
<p>After a query fails the driver might decide to retry it based on its <code>Retry Policy</code> and the query itself.
Retry policy can be configured for <code>Session</code> or just for a single query.</p>
<h3 id="retry-policies"><a class="header" href="#retry-policies">Retry policies</a></h3>
<p>By default there are two retry policies:</p>
<ul>
<li><a href="retry-policy/fallthrough.html">Fallthrough Retry Policy</a> - never retries, returns all errors straight to the user</li>
<li><a href="retry-policy/default.html">Default Retry Policy</a> - used by default, might retry if there is a high chance of success</li>
</ul>
<p>It's possible to implement a custom <code>Retry Policy</code> by implementing the traits <code>RetryPolicy</code> and <code>RetrySession</code>.</p>
<h3 id="query-idempotence"><a class="header" href="#query-idempotence">Query idempotence</a></h3>
<p>A query is idempotent if it can be applied multiple times without changing the result of the initial application</p>
<p>Specifying that a query is idempotent increases the chances that it will be retried in case of failure.
Idempotent queries can be retried in situations where retrying non idempotent queries would be dangerous.</p>
<p>Idempotence has to be specified manually, the driver is not able to figure it out by itself.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::query::Query;
use scylla::prepared_statement::PreparedStatement;

// Specify that a Query is idempotent
let mut my_query: Query = Query::new(&quot;SELECT a FROM ks.tab&quot;.to_string());
my_query.set_is_idempotent(true);


// Specify that a PreparedStatement is idempotent
let mut prepared: PreparedStatement = session
    .prepare(&quot;SELECT a FROM ks.tab&quot;)
    .await?;

prepared.set_is_idempotent(true);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="fallthrough-retry-policy"><a class="header" href="#fallthrough-retry-policy">Fallthrough retry policy</a></h1>
<p>The <code>FalthroughRetryPolicy</code> never retries, returns errors straight to the user. Useful for debugging.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p>To use in <code>Session</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::{Session, SessionBuilder};
use scylla::transport::retry_policy::FallthroughRetryPolicy;

let session: Session = SessionBuilder::new()
    .known_node(&quot;127.0.0.1:9042&quot;)
    .retry_policy(Box::new(FallthroughRetryPolicy::new()))
    .build()
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>To use in a <a href="retry-policy/../queries/simple.html">simple query</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::query::Query;
use scylla::transport::retry_policy::FallthroughRetryPolicy;

// Create a Query manually and set the retry policy
let mut my_query: Query = Query::new(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;.to_string());
my_query.set_retry_policy(Box::new(FallthroughRetryPolicy::new()));

// Run the query using this retry policy
let to_insert: i32 = 12345;
session.query(my_query, (to_insert,)).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>To use in a <a href="retry-policy/../queries/prepared.html">prepared query</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::prepared_statement::PreparedStatement;
use scylla::transport::retry_policy::FallthroughRetryPolicy;

// Create PreparedStatement manually and set the retry policy
let mut prepared: PreparedStatement = session
    .prepare(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;)
    .await?;

prepared.set_retry_policy(Box::new(FallthroughRetryPolicy::new()));

// Run the query using this retry policy
let to_insert: i32 = 12345;
session.execute(&amp;prepared, (to_insert,)).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="default-retry-policy"><a class="header" href="#default-retry-policy">Default retry policy</a></h1>
<p>This is the retry policy used by default. It retries when there is a high chance that it might help.<br />
This policy is based on the one in <a href="https://docs.datastax.com/en/developer/java-driver/4.11/manual/core/retries/">DataStax Java Driver</a>.
The behaviour is the same.</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<p>To use in <code>Session</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::{Session, SessionBuilder};
use scylla::transport::retry_policy::DefaultRetryPolicy;

let session: Session = SessionBuilder::new()
    .known_node(&quot;127.0.0.1:9042&quot;)
    .retry_policy(Box::new(DefaultRetryPolicy::new()))
    .build()
    .await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>To use in a <a href="retry-policy/../queries/simple.html">simple query</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::query::Query;
use scylla::transport::retry_policy::DefaultRetryPolicy;

// Create a Query manually and set the retry policy
let mut my_query: Query = Query::new(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;.to_string());
my_query.set_retry_policy(Box::new(DefaultRetryPolicy::new()));

// Run the query using this retry policy
let to_insert: i32 = 12345;
session.query(my_query, (to_insert,)).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>To use in a <a href="retry-policy/../queries/prepared.html">prepared query</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>use scylla::prepared_statement::PreparedStatement;
use scylla::transport::retry_policy::DefaultRetryPolicy;

// Create PreparedStatement manually and set the retry policy
let mut prepared: PreparedStatement = session
    .prepare(&quot;INSERT INTO ks.tab (a) VALUES(?)&quot;)
    .await?;

prepared.set_retry_policy(Box::new(DefaultRetryPolicy::new()));

// Run the query using this retry policy
let to_insert: i32 = 12345;
session.execute(&amp;prepared, (to_insert,)).await?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="driver-metrics"><a class="header" href="#driver-metrics">Driver metrics</a></h1>
<p>During operation the driver collects various metrics.</p>
<p>They can be accessed at any moment using <code>Session::get_metrics()</code></p>
<h3 id="collected-metrics"><a class="header" href="#collected-metrics">Collected metrics:</a></h3>
<ul>
<li>Query latencies</li>
<li>Total number of nonpaged queries</li>
<li>Number of errors during nonpaged queries</li>
<li>Total number of paged queries</li>
<li>Number of errors during paged queries</li>
<li>Number of retries</li>
</ul>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate scylla;
</span><span class="boring">use scylla::Session;
</span><span class="boring">use std::error::Error;
</span><span class="boring">async fn check_only_compiles(session: &amp;Session) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>let metrics = session.get_metrics();

println!(&quot;Queries requested: {}&quot;, metrics.get_queries_num());
println!(&quot;Iter queries requested: {}&quot;, metrics.get_queries_iter_num());
println!(&quot;Errors occured: {}&quot;, metrics.get_errors_num());
println!(&quot;Iter errors occured: {}&quot;, metrics.get_errors_iter_num());
println!(&quot;Average latency: {}&quot;, metrics.get_latency_avg_ms().unwrap());
println!(
    &quot;99.9 latency percentile: {}&quot;,
    metrics.get_latency_percentile_ms(99.9).unwrap()
);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="query-tracing"><a class="header" href="#query-tracing">Query tracing</a></h1>
<p>Query tracing is still in development, see pull request <a href="https://github.com/scylladb/scylla-rust-driver/pull/199">#199</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
